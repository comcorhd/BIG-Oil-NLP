
Modelagem Direta 2.1 Introdução A geofísica pode ser entendida como uma tecno-ciência que busca levantar característica de subsuperfície a partir de dados obtidos por métodos empregados em superfície, em poços, ou mesmo no ar. Por outro lado, a física envolvida nestes métodos é tal que apenas se conhecem os dados de resposta, os quais, supostamente, advêm de algum modelo único, porém desconhecido, que representa a subsuperfície. De maneira geral, o dados geofísicos são discretizados, havendo óbvia relação entre estes e o modelo. Admitindo que esta relação é linear, pode-se escrever: (2.1) Nesta equação, d simboliza o vetor de dados d = [d1 d2 ··· dM ]T , m representa o vetor de parâmetros do modelo m = [m1 m2 ··· mN ]T . A matriz GM⇥N dá a correlação entre o vetor de dados d e o vetor de parâmetros do modelo m. Quando se conhece o modelo m e, a partir deste, se obtém os dados d, a operação é conhecida como modelagem direta; se, por outro lado, são conhecidos os dados d e, a partir destes, se objetiva descobrir o modelo m que os geram, então a operação é conhecida como modelagem inversa (ou, simplesmente, inversão). Isto está ilustrado na Fig. 2.1.

Figura 2.1: Relação entre modelo e dados.
Neste trabalho, o vetor m de parâmetros compreende o conjunto dos coeﬁcientes da série ondaleta que representa o modelo de subsuperfície, ao passo que o vetor de dados d é a coleção dos tempos de trânsito das ondas sísmicas compressionais (apenas as primeiras chegadas foram computadas, como será explicado adiante). A modelagem direta foi amplamente utilizada, tanto para a obtenção dos tempos de trânsito dos raios sísmicos no modelo alvo (sintético), como para a obtenção dos tempos trânsito nos modelos correntes, trabalhados nos algoritmos de inversão; o processo de obtenção destes tempos de trânsito é descrito a seguir.
2.2 A Teoria do Raio O traçamento de raios é uma técnica utilizada na modelagem direta dos tempos de trânsito das ondas sísmicas em subsuperfície. Fundamenta-se na teoria do raio sísmico, o qual tem origem na propagação de ondas sísmicas (sejam ondas compressionais ou cisalhantes) em subsuperfície nos meios heterogêneos. A teoria do raio resulta da suposição de existência da solução de altas frequências para a equação elastodinâmica e, assim sendo, a solução obtida para a propagação das ondas nos meios elásticos não é exata (Martinez e Figueiró, 2011); ainda assim, este recurso reproduz com boa ﬁdelidade as linhas perpendiculares às frentes de onda em meios isotrópicos, que são as trajetórias dos raios sísmicos. No que concerne aos problemas práticos relacionados à prospecção e exploração de hidrocarbonetos, tal suposição encontra boa aplicabilidade.
A parte relativa aos aspectos práticos do traçamento de raios está transcrita do trabalho de (Dos Santos, 2009) e é a seguir apresentada.
O traçamento de raios usa uma solução particular do sistema de equações do raio (ˆCervenˆy, 2001): (2.2) .
(2.3) , na qual o parâmetro ⌧, é dado por: (2.4) Não existe signiﬁcado físico para a variável ⌧, no entanto a mesma possui dimensão L2 · T 1, de sorte que, no Sistema Internacional de Medidas (SI), possui a unidade de m2 · s1. Na Eq. (2.4), T é o tempo de trânsito da onda sísmica ao longo da trajetória descrita pelo raio e dT é o elemento de integração temporal.
Objetivando-se obter um algoritmo que permita o traçamento numérico das trajetórias dos raios, expande-se as Eqs.
(2.3) em série de Taylor, truncando-as a partir dos termos de segunda ordem (Dos Santos, 2009), o que resulta em: (2.5) O vetor vagarosidade é atualizado, constantemente, através da Eq. (2.6) para satisfazer a condição da equação iconal, em cada nó da poligonal na trajetória do raio, isto é: (2.6) O sistema de Eqs. (2.5) é, em última análise, a base para um algoritmo que permite calcular numericamente a trajetória do raio sísmico, bem como o tempo de trânsito das ondas sísmicas ao longo destas trajetórias. Assim, foi possível escrever um programa (linguagem fortran), que foi usado para simular a propagação de ondas sísmicas compressionais em campos de velocidades sísmicas.
2.3 Cálculo do Tempo de Trânsito ao longo do Raio Sísmico (2.7) Um ponto da malha (xi, zi) apresenta velocidade vi, que não é necessariamente igual à velocidade do ponto (xi+1, zi+1), daí o fato de que a Eq. (2.7) ser, na realidade, uma aproximação, podendo ser reescrita como segue: (2.8) distância entre os pontos (xN , zN ) e (xN +1, zN +1), de sorte que a razão entre esta distância e a velocidade vN resulta no tempo de deslocamento da onda entre estes dois pontos (tempo da (N + 1)-ésima iteração).
2.4 Metodologia empregada na Modelagem Direta dos Tempos de Trânsito 2.4.1 Geometria 1. A clara melhoria na iluminação do modelo; 2. Redução do tempo de processamento, uma vez que, com 4 fontes e 20 receptores, são formados (considerando-se apenas as primeiras chegadas) no máximo 80 pares fonte-receptor (deve-se levar em conta que alguns receptores não são iluminados).
Figura 2.2: Distribuição das fontes (Si) em poços e receptores (Rj) ﬁxos na superfície do modelo da falha distensional.
2.4.2 Ligação Fonte-Receptor Um problema concernente à aplicação da teoria do traçamento de raios é conseguir conectar posições de fontes e receptores, conhecido como Two-Point Ray Tracing Problem; há algumas formas de resolver este problema, como: 1. Tentativa e erro, até encontrar o ângulo correto de saída do raio, que conecta fonte e receptor. Método de fácil implementação, porém com alto custo de processamento; 2. Aplicar o algoritmo da bisseção a ﬁm de encontrar o ângulo de saída do raio. Tem uma implementação um pouco menos simples, requer menos iterações que a primeira solução. Por outro lado, deve-se levar em consideração que pequenas variações no ângulo de saída do raio podem resultar em grandes afastamentos dos pontos de chegada deste à superfície; 3. Aplicação do algoritmo de Newton-Raphson; este surge como um melhoramento ao método da bisseção, tendo convergência mais rápida e, portanto, é mais eﬁciente do ponto de vista computacional. Por outro lado, não é capaz de resolver o problema quando o campo de velocidades apresenta pontos cáusticos; 4. Lançar uma quantidade constante e razoável de raios de cada fonte, com ângulos igualmente espaçados entre eles, e considerar que o raio atinge certo receptor quando este chega em posição aproximada daquela na qual o receptor realmente se encontra.
É um método de caráter aproximado, de fácil implementação e de número de iterações controlado, ou seja, pode-se prever e regular seu custo computacional.
Neste trabalho foram testadas as soluções descritas nos itens 3 e 4, tendo sido adotada a última. A razão disto, além da obtenção de maior taxa de sucesso, é que foi possível realizar o traçamento de raios em poucos segundos (os tempos de processamento giram em torno de alguns décimos até 6 segundos). Como tolerância na separação entre a posição do receptor e o ponto de chegada do raio, foi adotada 1 
do espaçamento entre receptores.
2.4.3 Primeiras Chegadas e Processamento Paralelo Por uma questão de simpliﬁcação, tanto de implementação quanto do processamento, apenas os tempos das primeiras chegadas foram considerados. O algoritmo foi concebido de tal maneira que todo raio que chega à superfície é associado ao receptor mais próximo; este raio é substituído por outro, caso este se aproxime ainda mais do receptor. Se dois ou mais raios são associados ao mesmo receptor (mesma distância em relação à este) será considerado aquele de menor tempo de trânsito ou seja, são computadas apenas primeiras chegadas. A quantidade de raios que parte de cada fonte variou ao longo de diversas experimentações feitas no trabalho, de 75 a 5.000; obviamente isto inﬂuencia no tempo de processamento.
O uso de processamento paralelo 1 foi intenso em todo o trabalho; no traçamento de raios, não foi diferente. Como cada fonte independe da outra, o processamento dos raios se deu de forma paralela, ou seja, cada fonte teve seus raios traçados num núcleo independente do processador, totalizando 4 núcleos de processamento. Isto signiﬁca que o traçamento de raios foi feito com uma velocidade aproximadamente 4 vezes maior do que se fosse feito de modo serial (note-se que há partes do código que não são paralelizáveis).
1A programação em paralelo, neste trabalho, consistiu na inserção das diretivas OpenMP nos códigos originais. Uma apresentação destas diretivas encontra-se no Anexo I.

Modelagem Inversa 3.1 Introdução • Existência: O sistema linear deve possuir solução; • Unicidade: A solução deve ser única. Como não se conhece de fato a subsuperfície, é possível obter-se mais de um modelo que leve às mesmas respostas físicas obtidas a partir do modelo verdadeiro, o que conﬁguraria uma ambiguidade da solução. Dito de 
modo mais simples: diferentes modelos podem gerar o mesmo dado; e • Estabilidade: A solução deve ser robusta à ponto de não ser facilmente perturbada a partir de pequenas variações (presença de ruído) nos dados de entrada.
O problema é dito mal posto quando não atende à pelo menos um destes critérios sendo que, no geral, inversões geofísicas são problemas mal postos, exatamente por falharem no critério da unicidade ou estabilidade (Rodrigues, 2015). Informações a priori, dados geofísicos obtidos por outros métodos, dados geológicos e tratamentos numéricos tendem a reduzir a ambiguidade e melhorar a estabilidade do problema.
3.2 Problemas não Lineares A maior parte dos problemas geofísicos guarda uma relação não linear entre o vetor de dados, d, e o modelo, m, podendo a Eq. (2.1) ser reescrita como segue: (3.1) na qual g é o operador de modelagem direta (Sen e Stoﬀa, 2013). Neste sentido, a busca pelo modelo m que satisfaça à Eq. 3.1 para um vetor de dados, d, conhecido, passa a ser uma tarefa ainda mais difícil quando comparada com o caso linear.
Os métodos de modelagem inversa (ou, simplesmente, inversão) usados com este objetivo podem ser classiﬁcados em dois grandes grupos: • Métodos de escopo global: de maneira geral carregam nos seus algoritmos o uso de alguma técnica envolvendo aleatoriedade, na busca por um mínimo global da função erro objetivo. Como vantagem, apresentam uma menor dependência do modelo inicial, porém, sua convergência é mais demorada e menos acurada. Os métodos de escopo global mais conhecidos são: Monte Carlo (usado neste trabalho), Simulated Annealing, Algoritmo Genético, Redes Neurais, e etc.
• Métodos de escopo local: a busca pelo mínimo da função erro objetivo se restringe ao mínimo local; exatamente por isso, guardam maior dependência do modelo inicial.
Tem convergência muito mais rápida que os algoritmos de escopo global, entretanto o modelo corrente não pode estar muito longe do mínimo global ou do domínio de convergência do método. Os métodos de escopo local mais conhecidos são: “Steepest Descent”, Newton e o de Gauss-Newton (que foi utilizado nesta pesquisa).
Diante do exposto, evidencia-se a comum associação entre os métodos: os de escopo global prestam-se a aproximar o modelo corrente do mínimo global, garantindo um bom modelo inicial para uso num método de escopo local.
3.3 A Função Erro Objetivo (3.2) de tal modo que, tomando novamente como base a Eq. (3.1), surge claramente a relação entre dcalc e mest : (3.3) A função erro utilizada nesta pesquisa, tanto para o método de Monte Carlo, quanto para o de Gauss-Newton foi o erro RMS (Root-Mean-Square ou, em livre tradução, Raiz Quadrática Média). Sendo E o símbolo empregado para esta função, então: (3.4) na qual E(dcalc mest j ) é o erro RMS associado ao vetor de dados dcalc do j-ésimo modelo estimado, j j .
3.4 Método de Monte Carlo Método de escopo global cuja ﬁlosoﬁa básica consiste numa busca aleatória de um modelo, dentro do espaço de modelos (Sen e Stoﬀa, 2013), para o qual os dados calculados através da Eq. (3.3) minimizem a função erro objetivo.
calcular os dados a partir deste modelo pela Eq. (3.3). De posse destes dados calculados e dos dados observados, calcula-se o erro entre estes, por alguma função objetivo (norma L2, erro RMS, e etc).
Logo em seguida, são criadas perturbações aleatórias nos parâmetros, a ﬁm obter-se um (3.5) As perturbações aleatórias mI modo: n que aparecem na Eq. (3.5) podem ser geradas do seguinte 3. A perturbação absoluta, em cada parâmetro, será então o produto de a pelo respectivo De posse do modelo provisório mP , o próximo passo é gerar o vetor de dados calculados, novamente pela Eq.
(3.3). Calcula-se então o erro associado a este modelo provisório e compara-se com o erro anterior. Se o erro baixar, o modelo provisório é aceito e novas perturbações serão feitas, a partir dele; caso contrário, o modelo é rejeitado e nova perturbação é feita no modelo inicial. O processo se repete, até que se atinja um valor ideal para o erro (critério de parada).
Ocorre, por outro lado, o risco de ser atingido um mínimo local da função erro objetivo (vide Fig. 3.1), levando a um modelo ﬁnal não conveniente. Uma forma de fazer o algoritmo “escapar” de um mínimo local, é usando uma função probabilidade.
Figura 3.1: Comportamento de uma função erro hipotética em relação aos modelos (Sen e Stoﬀa, 2013). Os pontos 1, 2 e 3 representam modelos iniciais; também são indicados os mínimos global e locais.
Um modelo que seria originalmente descartado pelo critério de minimização do erro, pode ser aproveitado se satisﬁzer algum outro critério, dado por uma função probabilidade. Um exemplo de função probabilidade é a exponencial do erro: (3.6) Uma descrição esquemática, com algumas adaptações, para a metodologia que foi empregada neste trabalho, pode ser encontrada na Fig. 3.3.
3.5 Método de Gauss-Newton Método de escopo local, também conhecido como inversão linearizada, parte do pressuposto de que os dados variam linearmente com os parâmetros do modelo na região próxima a este (Rodrigues, 2015). Por isto, é um método altamente dependente do modelo inicial. Na Fig.
3.1, por exemplo, se os modelos iniciais adotados fossem o 2 ou 3, fatalmente o método faria a função erro convergir em um mínimo local e, consequentemente, daria como solução modelos distantes do modelo alvo.
Seja dobs o vetor de dados observados (tempos de trânsito obtidos a partir do modelo alvo sintético, m) e dcalc o vetor de dados calculados para um modelo estimado mest de tal sorte que, supondo válida a premissa acima: (3.7) e (3.8) Por questões de sintetização de notação, o modelo estimado, mest, será simbolizado apenas por ml, que é um modelo qualquer, corrente, na l-ésima iteração. A função erro residual, neste caso é dada por (Dos Santos e Figueiró, 2011): (3.9) Expandindo a Eq. (3.9) numa série de Taylor até a primeira ordem, vem: (3.10) O termo ml que a parece na Eq. (3.10) é a diferença: (3.11) na qual m0 é um modelo de referência, não necessariamente o inicial (Dos Santos e Figueiró, 2011). A matriz S é conhecida como matriz sensibilidade e pode ser calculada para um l-ésimo modelo corrente qualquer. A matriz S(ml) tem suas entradas sp,q calculadas do seguinte modo: (3.12) Resolvendo a expressão contida na Eq. (3.10), para ml, obtém-se: (3.13) A Eq. (3.13) pode ser entendida como o núcleo do algoritmo de Gauss-Newton, uma vez que se pode obter um fator de atualização, ml, do modelo corrente, ml, a partir da matriz sensibilidade, S(ml) e do vetor erro residual, d(ml). Neste sentido, a parte mais importante do método é, sem dúvida, a construção da matriz sensibilidade em cada iteração.
Os modelos podem então ser constantemente atualizados; um novo modelo é obtido a partir do atual, ml e do fator de atualização, ml. Para tanto, basta um rearranjo na Eq. (3.11), resultando em: (3.14) O processo se repete, até que algum critério de parada seja atingido. O modelo invertido será, portanto, o mais atualizado ao ﬁm do algoritmo.
3.6 Metodologia Empregada na Inversão 3.6.1 Monte Carlo O início do processo de inversão se dá com a aplicação do algoritmo de Monte Carlo. Para tanto, o programa concebido tem como insumos os coeﬁcientes das séries ondaleta que parametrizam os modelos alvo, m e inicial m0, este último representado na Fig. 3.2. É importante que a quantidade de coeﬁcientes seja a mesma, já que se pretende chegar ao modelo alvo a partir do inicial. Além disso, a mesma geometria de aquisição foi usada para a obtenção dos tempos de trânsito sintéticos.
Figura 3.2: Modelo inicial m0: homogêneo com velocidade igual a 3, 0 km/s.
Uma vez dentro do programa, os coeﬁcientes servem ao cálculo dos tempos de trânsito tanto para o modelo alvo (sendo criado o vetor Tobs) como para o modelo inicial (o vetor T1 é calculado), conforme consta na Fig. 3.3.
Os vetores Tobs e T1 são respectivamente: (3.15) e (3.16) 3.6.1.1 Cálculo do Erro O erro da iteração w-ésima é calculado, com a aplicação da Eq. (3.4) substituindo o vetor de dados calculados, dcalc, pelo vetor Tw e o vetor de dados observados, dobs, por Tobs, ou seja: (3.17) de sorte que o vetor Tw é : (3.18) Vale a ressalva de que os somatórios, tanto no numerador quanto no denominador da Eq.
(3.4), somente são atualizados se tw i e tobs são não nulos (receptores iluminados).
i 3.6.1.2 Perturbação do Modelo e Range Sísmico 1. Uma faixa de perturbação é adotada, por exemplo de 0, 1% à 8, 0%; 2. Um número (pseudo) aleatório A é obtido e este é normalizado a ﬁm de que se torne um valor dentro da faixa adotada; 3. Este valor é então multiplicado pelo coeﬁciente cn obtendo-se a perturbação absoluta cn; alterados e se crie assim, um novo modelo.
Uma importante adaptação em relação ao algoritmo original foi a rejeição de modelos cujas velocidades produzidas não sejam características das ondas sísmicas, como, por exemplo, velocidades abaixo de 1, 5 km/s ou acima de 10, 0 km/s .
Isto representa uma economia enorme de processamento, haja vista que o traçamento de raios, para a obtenção dos tempos de trânsito do modelo corrente, é a parte mais custosa do algoritmo.
3.6.1.3 Critérios de Parada No programa que foi usado neste trabalho, há dois critérios de parada. O primeiro é o número de iterações; o programa é interrompido, a despeito do valor do erro corrente, se as iterações atingirem um número limite. Valores típicos usados foram em torno de 5.000 à 35.000 iterações. O segundo é o valor do erro RMS; espera-se que, com o avançar das iterações, o erro RMS entre os tempos de trânsito dos modelos correntes (dados calculados) e aqueles do modelo alvo (dados observados) baixe progressivamente, até ser atingido um valor ótimo, inicialmente arbitrado.
Uma visão esquemática do que fora dito nos parágrafos anteriores encontra-se na Fig. 3.3. O último modelo atualizado no algoritmo de Monte Carlo (produto) serve como modelo inicial para o algoritmo de Gauss-Newton (insumo).
Figura 3.3: Fluxograma do algoritmo de Monte Carlo, adaptado ao trabalho aqui desenvolvido.
3.6.2 Gauss-Newton O programa do método de Gauss-Newton, desenvolvido para este trabalho, também tem como insumos os coeﬁcientes das séries ondaleta que parametrizam os modelo alvo e inicial.
Desta vez, entretanto, o modelo inicial é aquele obtido como produto do algoritmo de Monte Carlo. Inicialmente os tempos de trânsito de ambos os modelos são calculados, bem como o erro RMS inicial.
O método, grosso modo, visa alimentar a Eq. (3.13), lembrando-se que a função erro residual d(ml) é na realidade um vetor erro nos tempos, Tl de tal sorte que: (3.19) Assim sendo: (3.20) Claramente é muito simples, inclusive computacionalmente, calcular o vetor Tl em cada iteração l do algoritmo de Gauss-Newton. Assim sendo, uma vez montada a matriz sensibilidade, S, todo o processo se torna cálculo matricial de transposições, multiplicações, inversões e somas.
3.6.2.1 A matriz Sensibilidade A matriz sensibilidade tem tamanha importância para o algoritmo de Gauss-Newton que, no programa escrito para este trabalho, a subrotina dedicada à sua elaboração é a mais volumosa. A ﬁm de ilustrar como esta matriz é montada, bem como discutir a metodologia empregada, considere-se um modelo parametrizado por uma série ondaleta composta por 27 coeﬁcientes e cujo traçamento de raios é semelhante àquele mostrado na Fig. 5.6, ou seja, 4 fontes em dois poços e 20 receptores em superfície, totalizando 80 pares fonte-receptor. A matriz sensibilidade, para a l-ésima iteração, neste caso é: (3.21) A relação entre os tempos de trânsito tm e o vetor de coeﬁcientes C é de tal sorte complicada que não seria possível resolver as derivadas presentes na Eq. (3.21) de maneira analítica.
Sendo assim, optou-se por usar diferenças ﬁnitas; ocorre que a variação feita no vetor de coeﬁcientes é em APENAS UM dos coeﬁcientes, à medida que se avançam as colunas da matriz sensibilidade. Para ilustrar, será mostrado o processo de obtenção de dois dos termos sm,n da matriz S a saber, os termos s1,1 e s25,7. Para o termo s1,1: (3.22) onde, os vetores C+ e C, para o termo s1,1 (na realidade para todos os termos da primeira coluna), são respectivamente: (3.23) e (3.24) A quantidade c1 que aparece nas Eqs. (3.22), (3.23) e (3.24) é expressa como segue: (3.25) em que “f ator” 1 representa uma potência de 10.
Já para o termo s25,7, é (3.26) 1O fator escolhido indica a sensibilidade da derivada. Valores típicos usados neste trabalho foram de 103, 104, 105 e 106, sendo 104 o fator que gerou melhores resultados.
onde, os vetores C+ e C, para o termo s25,7 (na realidade para todos os termos da sétima coluna), são respectivamente: (3.27) e (3.28) A quantidade c7 que aparece nas Eqs. (3.26), (3.27) e (3.28) é expressa como segue: (3.29) Como já foi dito, o cálculo dos tempos de trânsito é feito de forma paralelizada, de maneira que as 4 fontes utilizadas em cada modelo têm seus raios processados em núcleos de processamento independentes. Note-se que o vetor de tempos de trânsito T = T(C+) contêm todos os tm tempos de trânsito obtidos com a variação para mais do n-ésimo coeﬁciente, e o vetor T = T(C) contêm todos os tm tempos de trânsito obtidos com a variação para menos.
Assim sendo, ﬁca clara a comodidade de montar a matriz sensibilidade S coluna por coluna: o programa paraleliza o cálculo para 8 núcleos de processamento, 4 deles trabalhando os tempos de trânsito da n-ésima coluna com a variação para mais e outros 4 fazendo o mesmo com a variação para menos. No ﬁm, os resultados são operados conforme exemplos das Eqs.
(3.22) e (3.26); isto signiﬁca uma velocidade quase oito vezes maior na montagem da matriz sensibilidade quando comparada à velocidade com a qual a mesma tarefa seria realizada se fossem calculados termo após termo.

Resultados Preliminares 4.1 Parametrização Unidimensional Aqui são apresentados os resultados obtidos no inicio do trabalho, com a parametrização unidimensional; essa etapa tem por objetivo a calibração dos algoritmos, bem como testar a eﬁcácia da série ondaleta chapéu mexicano para seu uso na parametrização de funções. No capítulo 1, foi proposta a parametrização da parábola restrita, Eq. (4.1) e Fig. 4.1, para este propósito, tal como segue: (4.1) domínio [0, 3].
Os resultados abaixo são absolutamente satisfatórios diferindo apenas na quantidade de pares 
ordenados colhidos da função f (x), usados na Eqs. (1.36) a (1.38) e nos valores dos índices j e k usados para formar a matriz na Eq. (1.38), o que implica em diferentes quantidades de coeﬁcientes.
4.1.1 Primeira Parametrização O primeiro resultado obtido foi a parametrização da parábola restrita utilizando-se 100 pares ordenados (x, f (x)), com valores de j 2 {1, 0, 1} e k 2 {6,5,··· , 5, 6}, totalizando 39 coeﬁcientes. O resultado está na Fig. 4.2: Figura 4.2: Parábola restrita parametrizada por série ondaleta unidimensional com 39 coeﬁcientes, amostrada em 100 pontos.
4.1.2 Segunda Parametrização Já na segunda parametrização, foram utilizados 50 pares ordenados (x, f (x)), com os mesmos valores de j e k da primeira parametrização. O resultado está na Fig. 4.3: Figura 4.3: Parábola restrita parametrizada por série ondaleta unidimensional com 39 coeﬁcientes, amostrada em 50 pontos.
4.1.3 Terceira Parametrização A última parametrização foi a que utilizou menos pares ordenados (x, f (x)) (35 pares, ao todo), e a menor quantidade de coeﬁcientes; j 2{ 0, 1, 2} e k 2{ 0, 1,··· , 7, 8}, totalizando 27 coeﬁcientes. O resultado, encontra-se apresentado na Fig. 4.4: Figura 4.4: Parábola restrita parametrizada por série ondaleta unidimensional com 27 coeﬁcientes, amostrada em 35 pontos 4.2 Parametrização Bidimensional Aqui novamente são apresentados resultados iniciais do trabalho, porém com a utilização da série ondaleta bidimensional. Para calibração do algoritmo, foi parametrizada uma curva correspondente à função sela restrita, cuja equação é: (4.2) Figura 4.5: Sela restrita. Os valores de f (x, y) são nulos fora do domínio [2, 2] ⇥ [2, 2].
Os coeﬁcientes que garantiram uma parametrização razoável desta função foram obtidos de forma empírica. Ao todo foram utilizados 1.521 coeﬁcientes, e os índices j1, j2, k1 e k2 variaram de modo sequencial entre os seguintes valores: .
A parametrização obtida encontra-se na Fig. 4.6: Figura 4.6: Função sela restrita parametrizada com 1.521 coeﬁcientes.

Resultados para Modelos de Campos de Velocidades Neste capítulo serão apresentados os resultados para campos de velocidades sísmicas trabalhados, desde a sua parametrização, utilizando diferentes quantidades de coeﬁcientes, até a modelagem inversa.
5.1 Modelo da Falha Distensional O primeiro modelo (M1) tratado neste trabalho foi o da falha distensional, representando 10 camadas sedimentares (separadas por interfaces não horizontais) em ambiente distensional.
O modelo foi suposto com 9, 0 km de extensão horizontal e 3, 0 km de profundidade. A apresentação gráﬁca de M1 é feita na Fig. 5.1: Figura 5.1: Modelo da falha distensional (M1).

Os modelos de campos de velocidades sísmicas parametrizados foram plotados de duas maneiras distintas, para cada quantidade de coeﬁcientes utilizada. A primeira foi a plotagem com o campo parametrizado sem qualquer ajuste, ou seja, ﬁdedigno às velocidades obtidas.
Na segunda, foi feito uma espécie de truncamento das velocidades; para a falha distensional, os valores das velocidades sísmicas foram, respectivamete 1,5; 1,7; 2,0; 2,2; 2,3; 2,5; 3,0; 3,5; 4,0 e 4,5 km/s, crescendo com a profundidade. Assim, qualquer velocidade menor que 1, 6 km/s teve seu valor arredondado para o vizinho mais próximo, ou seja, 1, 5 km/s; se o valor obtido situou-se entre 1, 6 km/s e 1, 85 km/s foi truncado para 1, 7 km/s, e assim sucessivamente. Este processo teve por objetivo, apenas, melhorar a visualização do modelo, já que realça detalhes ao evidenciar o limites entre as feições. Todo o processo posterior, como traçamento de raios e aplicação dos algoritmos de inversão levou em consideração os modelos sem ajustes.
5.1.1 Parametrizações A primeira parametrização (P1) foi obtida utilizando-se 27 coeﬁcientes; os índices foram j1 = j2 = 1, k1 2{ 0, 1, 2,··· , 8}, k2 2{ 0, 1, 2}. Sendo os coeﬁcientes apresentados na Tab.
5.1.
Tabela 5.1: Relação de índices e coeﬁcientes utilizados na parametrização da Falha Distensional, k2 d(j1, j2, k1, k2) 








-34,8517 -47,9853 -44,5835 -31,2458 -62,9992 -83,4823 -121,0372 -75,5884 13,5094 O campo de velocidades obtido com esta parametrização encontra-se na Fig. 5.2: A partir das parametrizações seguintes, as tabelas com os índices e coeﬁcientes não serão mais mostradas, por duas razões: a primeira é o volume de informação, as tabelas começariam a ﬁcar grandes demais; a segunda é o fato de que, tanto a modelagem direta como a inversa (modelos alvo e inicial) foram baseadas com parametrizações que utilizaram 27 Figura 5.2: Parametrização do modelo da falha distensional (M1,P1) com ondaleta bidimensional chapéu mexicano, com 27 coeﬁcientes.
coeﬁcientes.
A segunda parametrização (P2) originou melhores resultados que a primeira, utilizando 40 coeﬁcientes. Os índices foram j1 = j2 = 1, k1 2{ 0, 1, 2,··· , 9}, k2 2{ 0, 1, 2, 3}. O campo de velocidades obtido com esta parametrização é mostrado na Fig. 5.3: Uma última parametrização (P4) foi feita, desta vez utilizando 640 coeﬁcientes, corroborando a melhoria do resultado com o aumento da quantidade de parâmetros. Os índices foram: j1 e j2 2{ 0, 1, 2, 3}, k1 2{ 0, 1, 2,··· , 9}, k2 2{ 0, 1, 2, 3}. O campo de velocidades obtido com esta parametrização é mostrado na Fig. 5.5: Figura 5.3: Parametrização do modelo da falha distensional (M1,P2) com ondaleta Figura 5.4: Parametrização do modelo da falha distensional (M1,P3) com ondaleta bidimensional chapéu mexicano, com 160 coeﬁcientes.
Figura 5.5: Parametrização do modelo da falha distensional (M1,P4) com ondaleta bidimensional chapéu mexicano, com 640 coeﬁcientes.
5.1.2 Modelagem Direta: Traçamento de Raios Nesta seção, são apresentados os resultados do traçamento de raios para a falha distensional, tanto a plotagem dos raios, Fig. 5.6 quanto para os tempos de trânsito. A falha distensional servirá como modelo alvo, para o estudo da modelagem inversa. Assim sendo, os tempos de trânsito obtidos constituem os dados sintéticos a serem trabalhados. Dado o grau de processamento dos algoritmos de inversão, optou-se pela parametrização mais econômica, ou seja, aquela que só utilizou 27 coeﬁcientes. O traçado foi obtido, utilizando-se 2.000 raios partindo de cada fonte.
A partir deste traçamento, foram obtidos os tempos de trânsito, os quais estão organizados nos perﬁs de tempos de trânsito sintéticos, nas Figs. 5.7(a) à 5.7(d).
5.1.3 Inversão A ﬁm de proceder a modelagem inversa, foi proposto um modelo inicial, Mo1, bastante distante daquele a ser obtido. Para tanto, foi adotado um bloco de velocidade única, cujas dimensões são as mesmas do modelo alvo, conforme Fig. 5.8.
Figura 5.6: Traçamento de raios no modelo da falha distensional parametrizado por 27 coeﬁcientes (M1,P1). Foram usados 2.000 raios por fonte.
Esse modelo foi então parametrizado, adotando os mesmos índices j1, j2, k1 e k2 utilizados para parametrizar o modelo alvo, a ﬁm de garantir a mesma quantidade de coeﬁcientes; os índices e coeﬁcientes utilizados para parametrizar este modelo inicial encontram-se organizados na tabela 5.2 Respeitando a mesma geometria de aquisição utilizada para o modelo Tabela 5.2: Relação de índices e coeﬁcientes utilizados na parametrização do Modelo Inicial, Mo1, alvo, procede-se o traçamento de raios, como na Fig. 5.9.
Os tempos de trânsito no modelo inicial, obtidos com este traçamento, encontram-se organizados nos perﬁs de tempos de trânsito sintéticos, nas Figs. 5.10(a) à 5.10(d): Os coeﬁcientes dos modelo inicial e os tempos de trânsito do modelo alvo serão insumos para o algoritmo de Monte Carlo. O produto deste será, por sua vez, utilizado como insumo pelo Figura 5.7: Perﬁs de tempos de trânsito sintéticos para o modelo da falha distensional (M1,P1). Os tempos nulos são associados a receptores não iluminados.
algoritmo de Gauss-Newton. A Tab. 5.3 traz o relatório do processamento 1 de cada um dos algoritmos: A Fig. 5.11 traz o modelo invertido da falha distensional, M1,I, após a aplicação sequencial dos algoritmos de Monte Carlo e Gauss-Newton, para um modelo inicial de velocidade 1Para um detalhamento da máquina utilizada neste processamento, consultar o Anexo I Figura 5.8: Mo1, modelo inicial: bloco de velocidade única, 3, 0 km/s.
Figura 5.9: Traçamento de raios no modelo inicial Mo1; novamente, foram utilizados 2.000 raios partindo de cada fonte. Modelo parametrizado com 27 coeﬁcientes.
homogênea (Fig. 5.8) parametrizado com apenas 27 coeﬁcientes. Mesmo não sendo exatamente o modelo alvo proposto, guarda bastante semelhança, tanto nas feições, quanto nas velocidades.
Os índices e coeﬁcientes deste modelo invertido estão na Tab. 5.4. O traçamento de raios foi feito, representado na Fig. 5.12, a ﬁm de calcular os tempos de trânsito: Este traçamento originou os tempos de trânsito para o modelo da falha distensional invertido, M1,I, organizados nos perﬁs de tempos de trânsito sintéticos, nas Figs. 5.13(a) à 5.13(d).
Finalmente, foi feita uma comparação entre as velocidades dos modelos alvo e invertido, obtendo-se o mapa de contorno da diferença relativa, vide Fig. 5.14 Figura 5.10: Perﬁs de tempos de trânsito sintéticos para o modelo inicial (Mo1).
Os tempos nulos são associados a receptores não iluminados.
Tabela 5.3: Comportamento dos algoritmos de inversão - Falha Distensional.
Figura 5.11: Modelo Invertido, M1,I, obtido através dos algoritmos de Monte Carlo e Gauss-Newton combinados.
Tabela 5.4: Relação de índices obtidos para o Modelo Invertido, M1,I.
5.2 Modelo do Domo Salino O segundo modelo (M2) tratado neste trabalho foi o do domo salino, Fig. 5.15(a) representando 7 camadas sedimentares (separadas por interfaces não horizontais) e uma intrusão salina de velocidade mais elevada. Esta estrutura tem importância devido à sua propensão à formação de reservatórios de hidrocarbonetos. O modelo foi suposto com 5, 0 km de extensão horizontal e 3, 0 km de profundidade. A apresentação gráﬁca de M2 é feita na Fig. 5.15(b): As cores da paleta, usadas para plotar os modelos seguintes, foram alteradas em relação àquelas usadas nas plotagens concernentes à falha distensional. Isto possibilitou uma maior evidenciação das estruturas principais, fazendo com que não fossem necessárias as plotagens com velocidades truncadas.
Figura 5.12: Traçado de raios para o modelo da falha distensional, M1,I, obtido por inversão; 2.000 raios por fonte.
5.2.1 Parametrizações O campo de velocidades obtido com esta parametrização encontra-se na Fig. 5.16: 5.2.2 Modelagem Direta: Traçamento de Raios A Fig. 5.18 traz o traçamento de raios para o campo de velocidades do modelo do domo salino (M2,P1), parametrizado com 216 coeﬁcientes (quantidade mínima que garantiu uma parametrização satisfatória); este serviu como modelo alvo para o processo de inversão.
Foram utilizados 5.000 raios partindo de cada fonte. Como geometria de aquisição, foi repetido o arranjo utilizado para a falha distensional, ou seja, 4 fontes distribuídas em 2 poços e 20 receptores ﬁxos na superfície.
Os tempos de trânsito obtidos com o traçamento de raios estão organizados nos perﬁs de tempos de trânsito sintéticos, nas Figs. 5.19(a) à 5.19(d).
Figura 5.13: Perﬁs de tempos de trânsito sintéticos para o modelo da falha distensional obtido por inversão (M1,I). Os tempos nulos são associados a receptores não iluminados.
5.2.3 Inversão A ﬁm de proceder a modelagem inversa, foi proposto um modelo inicial, Mo2, formado por um grande bloco de velocidade uniforme, 2, 2 km/s, com uma intrusão de alta velocidade, 6, 0 km/s, partindo de sua base, porém sem deﬁnições de quaisquer detalhes de outras feições.
Tal modelo poderia ter sido proposto a partir de levantamentos de outros métodos geofísicos (gravimétrico, por exemplo) ou conhecimento da geologia local; uma representação do modelo Figura 5.14: Diferença relativa entre as velocidades do modelo invertido, M1,I e alvo parametrizado, M1,P1.
Figura 5.15: Domo salino.
pode ser vista na Fig. 5.20.
Esse modelo foi então parametrizado, adotando os mesmos índices j1, j2, k1 e k2 utilizados para parametrizar o modelo alvo, a ﬁm de garantir a mesma quantidade de coeﬁcientes; os índices e coeﬁcientes utilizados para parametrizar este modelo inicial encontram-se no Apêndice A, Tabs. A.3 e A.4. Respeitando a mesma geometria de aquisição utilizada para o modelo alvo, procede-se o traçamento de raios, como na Fig. 5.21.
Os tempos de trânsito no modelo inicial, obtidos com este traçamento, encontram-se organizados nos perﬁs de tempos de trânsito sintéticos, nas Figs. 5.22(a) à 5.22(d).
Os coeﬁcientes dos modelo inicial e os tempos de trânsito do modelo alvo serão insumos para o algoritmo de Monte Carlo. O produto deste será, por sua vez, utilizado como insumo pelo algoritmo de Gauss-Newton. A Tab. 5.5 traz o relatório do processamento 2 de cada um dos 2Para um detalhamento da máquina utilizada neste processamento, consultar o Anexo I Figura 5.16: Parametrização do modelo do domo salino (M2,P1) com ondaleta bidimensional chapéu mexicano, com 216 coeﬁcientes.
Figura 5.17: Parametrização do modelo do domo salino (M2,P2) com ondaleta bidimensional chapéu mexicano, com 600 coeﬁcientes.
algoritmos: A Fig. 5.23 traz o modelo invertido do domo salino, M2,I, após a aplicação sequencial dos algoritmos de Monte Carlo e Gauss-Newton, para o modelo inicial Mo2 (Fig. 5.20) parametrizado com 216 coeﬁcientes. Mesmo não sendo exatamente o modelo alvo proposto, guarda bastante semelhança, tanto nas feições, quanto na faixa de velocidades.
Figura 5.18: Traçamento de raios no modelo do domo salino parametrizado por 216 coeﬁcientes (M2,P1). Foram usados 5.000 raios por fonte.
Tabela 5.5: Comportamento dos algoritmos de inversão - Domo Salino.
Os índices e coeﬁcientes deste modelo invertido estão no Apêndice A, Tabs. A.5 e A.6. O traçamento de raios foi feito, representado na Fig. 5.24, a ﬁm de calcular os tempos de trânsito: Este traçamento originou os tempos de trânsito para o modelo da falha distensional invertido, M2,I, organizados nos perﬁs de tempos de trânsito sintéticos, nas Figs. 5.25(a) à 5.25(d).
Finalmente, foi feita uma comparação entre as velocidades dos modelos alvo (M2,P1) e invertido (M2,I), obtendo-se o mapa de contorno da diferença relativa, na Fig. 5.26: 5.3 Modelo do Intrusão de Alta Velocidade O terceiro modelo (M3) tratado neste trabalho foi o da intrusão de alta velocidade, com-posto por 6 camadas sedimentares e uma intrusão de velocidade mais elevada, levemente centralizada e amorfa. A representação gráﬁca do campo de velocidades para este modelo, Figura 5.19: Perﬁs de tempos de trânsito sintéticos para o modelo do domo salino (M2,P1). Os tempos nulos são associados a receptores não iluminados.
suposto com 8, 0 km de extensão horizontal e 4, 0 km de profundidade, é feita na Fig. 5.27: 5.3.1 Parametrizações A primeira parametrização satisfatória (P1) foi obtida utilizando-se 180 coeﬁcientes, portanto mais parâmetros do que fora utilizado para representar a falha distensional e menos do que foi utilizado para representar o domo salino. Os índices foram j1 e j2 2{ 0, 1}, Figura 5.20: Mo2, modelo inicial: bloco de velocidade única, 2, 2 km/s com uma intrusão de alta velocidade 6, 0 km/s Figura 5.21: Traçamento de raios no modelo inicial Mo2; novamente, foram utilizados 5.000 raios partindo de cada fonte. Modelo parametrizado com 216 coeﬁcientes.
k1 2{ 0, 1, ··· , 8}, k2 2{ 0, 1, 2, 3, 4}. Sendo os coeﬁcientes apresentados no Apêndice B, Tabs. B.1 e B.2.
O campo de velocidades obtido com esta parametrização encontra-se na Fig. 5.28: Figura 5.22: Perﬁs de tempos de trânsito sintéticos para o modelo inicial (Mo2).
Os tempos nulos são associados a receptores não iluminados.
Figura 5.23: Modelo Invertido, M2,I, obtido através dos algoritmos de Monte Carlo e Gauss-Newton combinados.
Figura 5.24: Traçado de raios para o modelo do domo salino, M2,I, obtido por inversão; 5.000 raios por fonte.
5.3.2 Modelagem Direta: Traçamento de Raios A Fig. 5.30 traz o traçamento de raios para o campo de velocidades do modelo da intrusão (M3,P1), parametrizado com 180 coeﬁcientes (quantidade mínima que garantiu uma parametrização satisfatória); este serviu como modelo alvo para o processo de inversão. Foram Figura 5.25: Perﬁs de tempos de trânsito sintéticos para o modelo do domo salino obtido por inversão (M2,I). Os tempos nulos são associados a receptores não iluminados.
utilizados 1.000 raios partindo de cada fonte. Como geometria de aquisição, também foi repetido o arranjo utilizado para a falha distensional.
Os tempos de trânsito obtidos com o traçamento de raios estão organizados nos perﬁs de tempos de trânsito sintéticos, nas Figs. 5.31(a) à 5.31(d).
Figura 5.26: Diferença relativa entre as velocidades do modelo invertido, M2,I e alvo parametrizado, M2,P1, para o domo salino.
Figura 5.27: Campo de velocidades original do modelo da intrusão de alta velocidade em escala de cores.
5.3.3 Inversão A ﬁm de proceder a modelagem inversa, foi proposto um modelo inicial, Mo3, formado por um grande bloco de velocidade uniforme, 2, 6 km/s, com uma intrusão de alta velocidade, 6, 0 km/s, levemente centralizada horizontalmente e mais próxima à superfície, porém sem deﬁnições de quaisquer detalhes de outras feições. Novamente, poderia ter sido um modelo Figura 5.28: Parametrização do modelo da intrusão de alta velocidade (M3,P1) com ondaleta bidimensional chapéu mexicano, com 180 coeﬁcientes.
Figura 5.29: Parametrização do modelo da intrusão de alta velocidade (M3,P2) com ondaleta bidimensional chapéu mexicano, com 405 coeﬁcientes.
proposto a partir de levantamentos de outros métodos geofísicos ou conhecimento da geologia local; uma representação do modelo pode ser vista na Fig. 5.32: Esse modelo foi então parametrizado, adotando os mesmos índices j1, j2, k1 e k2 utilizados para parametrizar o modelo alvo, a ﬁm de garantir a mesma quantidade de coeﬁcientes; os Figura 5.30: Traçamento de raios no modelo da intrusão de alta velocidade parametrizado por 180 coeﬁcientes (M3,P1). Foram usados 1.000 raios por fonte.
índices e coeﬁcientes utilizados para parametrizar Mo3 encontram-se no Apêndice B, Tabs.
B.3 e B.4. Respeitando a mesma geometria de aquisição utilizada para o modelo alvo, procede-se o traçamento de raios, como na Fig. 5.33.
Os tempos de trânsito no modelo inicial, obtidos com este traçamento, encontram-se organizados nos perﬁs de tempos de trânsito sintéticos, nas Figs. 5.34(a) à 5.34(d).
Os coeﬁcientes dos modelo inicial e os tempos de trânsito do modelo alvo serão insumos para o algoritmo de Monte Carlo. O produto deste será, por sua vez, utilizado como insumo pelo algoritmo de Gauss-Newton. A Tab. 5.6 traz o relatório do processamento 3 de cada um dos algoritmos: Tabela 5.6: Comportamento dos algoritmos de inversão - Intrusão de alta velocidade.
A Fig. 5.35 traz o modelo invertido da intrusão de alta velocidade, M3,I, após a aplicação sequencial dos algoritmos de Monte Carlo e Gauss-Newton, para o modelo inicial Mo3 (Fig.
3Para um detalhamento da máquina utilizada neste processamento, consultar o Anexo I Figura 5.31: Perﬁs de tempos de trânsito sintéticos para o modelo da intrusão de alta velocidade (M3,P1). Os tempos nulos são associados a receptores não iluminados.
5.32) parametrizado com 180 coeﬁcientes. Mesmo não sendo exatamente o modelo alvo proposto, guarda bastante semelhança, tanto nas feições, quanto nas velocidades.
Os índices e coeﬁcientes deste modelo invertido estão no Apêndice B, Tabs. B.5 e B.6. O traçamento de raios foi feito, representado na Fig. 5.36, a ﬁm de calcular os tempos de trânsito: Este traçamento originou os tempos de trânsito para o modelo da falha distensional invertido, Figura 5.32: Mo3, modelo inicial: bloco de velocidade única, 2, 6 km/s com uma intrusão de alta velocidade 6, 0 km/s.
Figura 5.33: Traçamento de raios no modelo inicial Mo3; novamente, foram utilizados 1.000 raios partindo de cada fonte. Modelo parametrizado com 180 coeﬁcientes.
M3,I, organizados nos perﬁs de tempos de trânsito sintéticos, nas Figs. 5.37(a) à 5.37(d).
Finalmente, foi feita uma comparação entre as velocidades dos modelos alvo (M3,P1) e invertido (M3,I), obtendo-se o mapa de contorno da diferença relativa, apresentado na Fig.
5.38 Figura 5.34: Perﬁs de tempos de trânsito sintéticos para o modelo inicial (Mo3).
Os tempos nulos são associados a receptores não iluminados.
Figura 5.35: Modelo Invertido, M3,I, obtido através dos algoritmos de Monte Carlo e Gauss-Newton combinados.
Figura 5.36: Traçado de raios para o modelo da intrusão de alta velocidade, M3,I, obtido por inversão; 1.000 raios por fonte.
Figura 5.37: Perﬁs de tempos de trânsito sintéticos para o modelo da intrusão de alta velocidade obtido por inversão (M3,I). Os tempos nulos são associados a receptores não iluminados.
Figura 5.38: Diferença relativa entre as velocidades do modelo invertido, M3,I e alvo parametrizado, M3,P1, para a intrusão de alta velocidade.

Conclusões A técnica de parametrização baseada em séries ondaletas, mostrou-se extremamente eﬁcaz, tanto no seu propósito de parametrizar funções uni e bidimensionais, como campos de velocidades sísmicas. No tocante à parametrização dos modelos de velocidades, ﬁcou claro, ao longo do trabalho, que o uso de uma maior quantidade de coeﬁcientes (parâmetros) acarreta uma melhoria na representação dos mesmos; não obstante, uma pequena quantidade de coeﬁcientes garante razoável acurácia e reduz sobremaneira o custo dos processos computacionais iterativos.
A modelagem direta dos campos de velocidade foi também bastante satisfatória. Por um lado, a técnica do traçamento de raios tem aplicação bastante facilitada quando uma função matemática contínua descreve este campo, caso das parametrizações empregadas, já que ondaleta chapéu mexicano é contínua; por outro, o baixo tempo no processamento destes traçamentos acarreta uma economia muito bem vinda nos tempos de processamento dos algoritmos de inversão. Se há de notar que as ﬁguras representativas de tais traçamentos exibem a eﬁcácia da técnica, já que o comportamento dos raios está de acordo com o esperado, teoricamente, para a propagação das ondas elásticas em subsuperfície.
Os modelos invertidos, ainda que não idênticos aos respectivos modelos alvos, tem a capacidade de destacar as principais feições, servindo bem ao propósito geofísico. As velocidades obtidas para os modelos invertidos estão muito próximas daquelas dos correspondentes modelos alvos, o que pode ser veriﬁcado nos mapas de contorno das diferenças relativas.
Provavelmente, às custas do aumento nos tempos de processamento, os resultados das inversões seriam tanto mais acurados quanto maiores fossem as quantidades de coeﬁcientes utilizados nas parametrizações. Além disso, se os algoritmos de traçamento dos raios e in- 
versão considerassem raios mais profundos (não só as primeiras chegadas), possivelmente os resultados seriam mais expressivos. Tais considerações serão investigadas em trabalhos futuros.
O coroamento da técnica seria a aplicação num dado tomográﬁco real; apesar de isto não ter sido feito, o caminho está pronto para tal e, num trabalho mais aprofundado, tanto a técnica desenvolvida como seus resultados serviriam de base para algoritmos com esta ﬁnalidade.
O processamento de várias etapas do trabalho em paralelo permitiu um dinamismo na obtenção dos resultados, uma vez que as tarefas são demasiadamente repetidas a ﬁm de eliminar possíveis erros.
